/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import type { AIContext, InsightType, AIInsightsResults, AIInsightsErrors, SyncEvent, PeriodicSyncEvent } from '@/types/serviceWorker';
import type { Workout } from '@/types/workout';
import type { MuscleStatus } from '@/types/muscle';
import type { PersonalRecord, StrengthProgression } from '@/types/analytics';

declare const self: ServiceWorkerGlobalScope;

// Precache all of the assets generated by the build process
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    ({ request, url }: { request: Request; url: URL }) => {
        if (request.mode !== 'navigate') {
            return false;
        }
        if (url.pathname.startsWith('/_')) {
            return false;
        }
        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        }
        return true;
    },
    createHandlerBoundToURL('/index.html')
);

// Cache AI-related API calls with IndexedDB persistence
// This allows AI responses to be cached across sessions
registerRoute(
    ({ url }) => url.pathname.includes('/api/ai') || url.searchParams.has('ai-cache'),
    new NetworkFirst({
        cacheName: 'ai-responses',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 24 * 60 * 60, // 24 hours
                purgeOnQuotaError: true,
            }),
        ],
    })
);

// Cache static assets
registerRoute(
    ({ request }) => request.destination === 'image' || request.destination === 'font',
    new CacheFirst({
        cacheName: 'static-assets',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
            }),
        ],
    })
);

// Background sync for AI requests (when offline)
self.addEventListener('sync', (event: SyncEvent) => {
    if (event.tag === 'ai-request-sync') {
        event.waitUntil(handleAISync());
    }
    
    if (event.tag === 'workout-reminder-sync') {
        event.waitUntil(checkScheduledWorkoutReminders());
    }
});

async function handleAISync(): Promise<void> {
    // This would handle queued AI requests when back online
    // Implementation depends on your specific needs
    console.log('[SW] Processing queued AI requests');
}

// Periodic background sync for AI refresh checks (every hour)
self.addEventListener('periodicsync', (event: PeriodicSyncEvent) => {
    if (event.tag === 'ai-refresh-check') {
        event.waitUntil(checkAIRefresh());
    }
    
    if (event.tag === 'recovery-check') {
        event.waitUntil(checkMuscleRecovery());
    }
});

async function checkAIRefresh(): Promise<void> {
    // Check if 24 hours have passed and trigger refresh if needed
    // This runs in the background even when app is closed
    console.log('[SW] Checking if AI refresh is needed');

    // Send message to clients to check refresh status
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'AI_REFRESH_CHECK',
            timestamp: Date.now(),
        });
    });
}

async function checkScheduledWorkoutReminders(): Promise<void> {
    console.log('[SW] Checking scheduled workout reminders');
    
    // Send message to clients to check and trigger reminders
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'CHECK_WORKOUT_REMINDERS',
            timestamp: Date.now(),
        });
    });
}

async function checkMuscleRecovery(): Promise<void> {
    console.log('[SW] Checking muscle recovery status');
    
    // Send message to clients to check muscle recovery
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'CHECK_MUSCLE_RECOVERY',
            timestamp: Date.now(),
        });
    });
}

// Handle messages from the main app
self.addEventListener('message', (event: MessageEvent) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }

    if (event.data && event.data.type === 'CACHE_AI_RESPONSE') {
        // Cache AI response in IndexedDB via Cache API
        const { fingerprint, insightType, data } = event.data;
        cacheAIResponse(fingerprint, insightType, data);
    }

    if (event.data && event.data.type === 'GET_CACHED_AI') {
        // Retrieve cached AI response
        const { fingerprint, insightType } = event.data;
        getCachedAIResponse(fingerprint, insightType).then((cached) => {
            event.ports[0].postMessage({ cached });
        });
    }

    if (event.data && event.data.type === 'FETCH_AI_INSIGHTS') {
        // Trigger background AI insights fetch
        const { context, fingerprint, insightTypes, userId, apiKey } = event.data;
        fetchAIInsightsInBackground(context, fingerprint, insightTypes, userId, apiKey)
            .catch((error) => {
                console.error('[SW] Background AI fetch failed:', error);
                sendMessageToClients('AI_INSIGHTS_ERROR', {
                    error: error.message,
                    fingerprint,
                    insightTypes,
                });
            });
    }

    // Notification scheduling handlers
    if (event.data && event.data.type === 'SCHEDULE_WORKOUT_REMINDER') {
        const { notification } = event.data;
        scheduleWorkoutReminderNotification(notification);
    }

    if (event.data && event.data.type === 'CANCEL_WORKOUT_REMINDER') {
        const { notificationId } = event.data;
        cancelScheduledNotification(notificationId);
    }

    if (event.data && event.data.type === 'SHOW_MUSCLE_RECOVERY_NOTIFICATION') {
        const { notification } = event.data;
        showMuscleRecoveryNotification(notification);
    }

    if (event.data && event.data.type === 'CLEAR_ALL_NOTIFICATIONS') {
        clearAllScheduledNotifications();
    }
});

// Notification storage in service worker
const scheduledNotifications = new Map<string, { timeoutId: number; notification: any }>();

async function scheduleWorkoutReminderNotification(notification: any): Promise<void> {
    const now = Date.now();
    const delay = notification.scheduledTime - now;

    if (delay <= 0) {
        // Schedule immediately if time has passed
        showWorkoutReminderNotification(notification);
        return;
    }

    const timeoutId = self.setTimeout(() => {
        showWorkoutReminderNotification(notification);
        scheduledNotifications.delete(notification.id);
    }, delay) as unknown as number;

    scheduledNotifications.set(notification.id, { timeoutId, notification });
}

function cancelScheduledNotification(notificationId: string): void {
    const scheduled = scheduledNotifications.get(notificationId);
    if (scheduled) {
        self.clearTimeout(scheduled.timeoutId);
        scheduledNotifications.delete(notificationId);
    }
}

function clearAllScheduledNotifications(): void {
    scheduledNotifications.forEach(({ timeoutId }) => {
        self.clearTimeout(timeoutId);
    });
    scheduledNotifications.clear();
}

async function showWorkoutReminderNotification(notification: any): Promise<void> {
    const title = `Workout Reminder: ${notification.data.workoutName || 'Workout'}`;
    const body = `Your ${notification.data.workoutName || 'workout'} is scheduled soon!`;
    const icon = '/assests/img/fittrackAI.png';
    const badge = '/assests/img/fittrackAI.png';

    const options: NotificationOptions = {
        body,
        icon,
        badge,
        tag: notification.id,
        requireInteraction: false,
        data: {
            type: 'workout_reminder',
            workoutId: notification.data.workoutId,
            url: '/planner',
        },
    };

    try {
        await self.registration.showNotification(title, options);
    } catch (error) {
        console.error('[SW] Failed to show workout reminder notification:', error);
    }
}

async function showMuscleRecoveryNotification(notification: any): Promise<void> {
    const muscleName = notification.data.muscle
        ? notification.data.muscle.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())
        : 'Muscle';
    
    const title = `${muscleName} is Ready!`;
    const body = `Your ${muscleName.toLowerCase()} has fully recovered and is ready for training`;
    const icon = '/assests/img/fittrackAI.png';
    const badge = '/assests/img/fittrackAI.png';

    const options: NotificationOptions = {
        body,
        icon,
        badge,
        tag: notification.id,
        requireInteraction: false,
        data: {
            type: 'muscle_recovery',
            muscle: notification.data.muscle,
            url: '/anatomy',
        },
    };

    try {
        await self.registration.showNotification(title, options);
    } catch (error) {
        console.error('[SW] Failed to show muscle recovery notification:', error);
    }
}

// Notification click handler
self.addEventListener('notificationclick', (event: NotificationEvent) => {
    event.notification.close();

    const data = event.notification.data;
    const url = data?.url || '/';

    event.waitUntil(
        self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clients) => {
            // Check if there's already a window/tab open with the target URL
            for (const client of clients) {
                if (client.url === url && 'focus' in client) {
                    return client.focus();
                }
            }
            // If not, open a new window/tab
            if (self.clients.openWindow) {
                return self.clients.openWindow(url);
            }
        })
    );
});

async function cacheAIResponse(
    fingerprint: string,
    insightType: string,
    data: unknown
): Promise<void> {
    try {
        const cache = await caches.open('ai-responses');
        const response = new Response(JSON.stringify(data), {
            headers: { 'Content-Type': 'application/json' },
        });
        await cache.put(`/ai-cache/${insightType}/${fingerprint}`, response);
    } catch (error) {
        console.error('[SW] Failed to cache AI response:', error);
    }
}

async function getCachedAIResponse(
    fingerprint: string,
    insightType: string
): Promise<unknown | null> {
    try {
        const cache = await caches.open('ai-responses');
        const cached = await cache.match(`/ai-cache/${insightType}/${fingerprint}`);

        if (cached) {
            return await cached.json();
        }

        return null;
    } catch (error) {
        console.error('[SW] Failed to get cached AI response:', error);
        return null;
    }
}

// Send message to all connected clients
async function sendMessageToClients(type: string, data: Record<string, unknown>): Promise<void> {
    try {
        const clients = await self.clients.matchAll({ includeUncontrolled: true });
        clients.forEach((client) => {
            client.postMessage({
                type,
                ...data,
                timestamp: Date.now(),
            });
        });
    } catch (error) {
        console.error('[SW] Failed to send message to clients:', error);
    }
}

// Fetch AI insights in background
async function fetchAIInsightsInBackground(
    context: AIContext,
    fingerprint: string,
    insightTypes: InsightType[],
    userId?: string,
    apiKey?: string
): Promise<void> {
    console.log('[SW] Starting background AI fetch for:', insightTypes);

    const results: AIInsightsResults = {};
    const errors: AIInsightsErrors = {};

    // Fetch each insight type in parallel
    const fetchPromises = insightTypes.map(async (insightType) => {
        try {
            let result: ProgressAnalysis | SmartAlerts | WorkoutRecommendations | null = null;

            if (insightType === 'progress') {
                result = await generateProgressAnalysisInSW(
                    context.currentMonthWorkouts,
                    context.personalRecords,
                    context.strengthProgression,
                    context.volumeTrend,
                    context.metrics.consistencyScore,
                    context.previousMetrics.consistencyScore,
                    context.metrics.workoutCount,
                    context.previousMetrics.workoutCount,
                    apiKey
                );
            } else if (insightType === 'insights') {
                result = await generateSmartAlertsInSW(
                    context.currentMonthWorkouts,
                    context.muscleStatuses,
                    context.readinessScore,
                    apiKey
                );
            } else if (insightType === 'recommendations') {
                result = await generateWorkoutRecommendationsInSW(
                    context.currentMonthWorkouts,
                    context.muscleStatuses,
                    context.readinessScore,
                    context.metrics.symmetryScore,
                    context.metrics.focusDistribution,
                    apiKey
                );
            }

            if (result) {
                results[insightType] = result;
                // Cache the result
                await cacheAIResponse(fingerprint, insightType, result);
            }
        } catch (error: any) {
            console.error(`[SW] Failed to generate ${insightType}:`, error);
            errors[insightType] = error.message || 'Unknown error';
        }
    });

    await Promise.allSettled(fetchPromises);

    // Send results back to main thread
    sendMessageToClients('AI_INSIGHTS_READY', {
        fingerprint,
        results,
        errors: Object.keys(errors).length > 0 ? errors : undefined,
    });
}

// Helper functions to generate AI insights in service worker
// These make direct API calls to Gemini since SW can't import modules
async function generateProgressAnalysisInSW(
    workouts: Workout[],
    personalRecords: PersonalRecord[],
    strengthProgression: StrengthProgression[],
    volumeTrend: Array<{ date: string; totalVolume: number }>,
    consistencyScore: number,
    previousConsistencyScore: number,
    workoutCount: number,
    previousWorkoutCount: number,
    apiKey?: string
): Promise<ProgressAnalysis> {
    if (!apiKey) {
        return generateMockProgressAnalysisInSW(
            workouts,
            personalRecords,
            volumeTrend,
            consistencyScore,
            previousConsistencyScore,
            workoutCount,
            previousWorkoutCount
        );
    }

    try {
        const workoutSummary = formatWorkoutSummaryForSW(workouts, personalRecords);
        const prSummary = personalRecords.length > 0
            ? personalRecords.slice(0, 10).map((pr) => `${pr.exerciseName}: ${pr.maxWeight}kg x ${pr.maxReps}`).join(', ')
            : 'No PRs yet';
        const volumeTrendSummary = volumeTrend.length > 20
            ? `${volumeTrend.slice(0, 10).map((v) => `${v.date}: ${v.totalVolume}kg`).join(', ')}... (${volumeTrend.length} total weeks)`
            : volumeTrend.map((v) => `${v.date}: ${v.totalVolume}kg`).join(', ');

        const prompt = `Analyze workout progress and provide insights in JSON format:
{
  "breakthrough": {
    "exercise": "exercise name or null",
    "projectedWeight": number or null,
    "improvementPercent": number or null,
    "reason": "brief explanation"
  },
  "plateaus": [{"exercise": "name", "weight": number, "weeksStuck": number, "suggestion": "tip"}],
  "formChecks": [{"exercise": "name", "issue": "description", "muscleGroup": "muscle"}],
  "trainingPatterns": [{"type": "sleep|caffeine|timing", "title": "title", "description": "description", "impact": "impact statement"}]
}

Workout data: ${workoutSummary}
PRs: ${prSummary}
Volume trend: ${volumeTrendSummary}
Consistency: ${consistencyScore}% (was ${previousConsistencyScore}%)
Workouts this month: ${workoutCount} (was ${previousWorkoutCount})

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
        
        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };
            
            const cleanObject = (obj: unknown): unknown => {
                if (typeof obj === 'string') return cleanString(obj);
                if (Array.isArray(obj)) return obj.map(cleanObject);
                if (obj && typeof obj === 'object') {
                    const cleaned: Record<string, unknown> = {};
                    for (const [key, value] of Object.entries(obj)) {
                        cleaned[key] = cleanObject(value);
                    }
                    return cleaned;
                }
                return obj;
            };
            
            const cleaned = cleanObject(parsed);
            
            return {
                breakthrough: cleaned.breakthrough?.exercise ? {
                    exercise: cleanString(cleaned.breakthrough.exercise),
                    projectedWeight: cleaned.breakthrough.projectedWeight,
                    improvementPercent: cleaned.breakthrough.improvementPercent,
                    reason: cleanString(cleaned.breakthrough.reason || ''),
                } : undefined,
                consistencyScore,
                consistencyChange: consistencyScore - previousConsistencyScore,
                workoutCount,
                workoutCountChange: workoutCount - previousWorkoutCount,
                volumeTrend: {
                    current: volumeTrend[volumeTrend.length - 1]?.totalVolume || 0,
                    previous: volumeTrend[0]?.totalVolume || 0,
                    changePercent: volumeTrend.length > 1 && volumeTrend[0].totalVolume > 0
                        ? ((volumeTrend[volumeTrend.length - 1].totalVolume - volumeTrend[0].totalVolume) / volumeTrend[0].totalVolume) * 100
                        : 0,
                    weeklyData: volumeTrend.map((v, i) => ({ week: `WEEK ${i + 1}`, volume: v.totalVolume })),
                },
                plateaus: (Array.isArray(cleaned.plateaus) ? cleaned.plateaus : []).map((p: unknown) => {
                    const plateau = p as Record<string, unknown>;
                    return {
                    exercise: cleanString(p.exercise || ''),
                    weight: p.weight,
                    weeksStuck: p.weeksStuck,
                    suggestion: cleanString(plateau.suggestion || ''),
                    };
                }),
                formChecks: (Array.isArray(cleaned.formChecks) ? cleaned.formChecks : []).map((f: unknown) => {
                    const formCheck = f as Record<string, unknown>;
                    return {
                    exercise: cleanString(f.exercise || ''),
                    issue: cleanString(f.issue || ''),
                    muscleGroup: cleanString(formCheck.muscleGroup || ''),
                    };
                }),
                trainingPatterns: (Array.isArray(cleaned.trainingPatterns) ? cleaned.trainingPatterns : []).map((t: unknown) => {
                    const pattern = t as Record<string, unknown>;
                    return {
                    type: t.type,
                    title: cleanString(t.title || ''),
                    description: cleanString(t.description || ''),
                    impact: cleanString(pattern.impact || ''),
                    };
                }),
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockProgressAnalysisInSW(
        workouts,
        personalRecords,
        volumeTrend,
        consistencyScore,
        previousConsistencyScore,
        workoutCount,
        previousWorkoutCount
    );
}

async function generateSmartAlertsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number,
    apiKey?: string
): Promise<SmartAlerts> {
    if (!apiKey) {
        return generateMockSmartAlertsInSW(workouts, muscleStatuses, readinessScore);
    }

    try {
        const muscleSummary = formatMuscleStatusForSW(muscleStatuses);
        const workoutSummary = formatWorkoutSummaryForSW(workouts);

        const prompt = `Generate smart alerts in JSON format:
{
  "readinessStatus": "optimal|good|moderate|low",
  "readinessMessage": "actionable message",
  "criticalAlerts": [{"type": "critical|warning", "title": "title", "message": "message", "muscleGroup": "muscle"}],
  "suggestions": [{"type": "deload|sleep|nutrition", "title": "title", "description": "description"}],
  "nutritionEvents": [{"time": "HH:MM", "relativeTime": "In X mins", "title": "title", "description": "description", "type": "protein|carb|meal"}]
}

Readiness: ${readinessScore}%
Muscle status: ${muscleSummary}
Recent workouts: ${workoutSummary}

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
        
        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };
            
            return {
                readinessScore,
                readinessStatus: parsed.readinessStatus || 'good',
                readinessMessage: cleanString(parsed.readinessMessage || 'System is operating normally.'),
                criticalAlerts: (Array.isArray(parsed.criticalAlerts) ? parsed.criticalAlerts : []).map((a: unknown, i: number) => {
                    const alert = a as Record<string, unknown>;
                    return {
                    id: `alert-${i}`,
                    type: a.type,
                    title: cleanString(a.title || ''),
                    message: cleanString(a.message || ''),
                    muscleGroup: cleanString(alert.muscleGroup || ''),
                    };
                }),
                suggestions: (Array.isArray(parsed.suggestions) ? parsed.suggestions : []).map((s: unknown, i: number) => {
                    const suggestion = s as Record<string, unknown>;
                    return {
                    id: `suggestion-${i}`,
                    type: s.type,
                    title: cleanString(s.title || ''),
                    description: cleanString(suggestion.description || ''),
                    };
                }),
                nutritionEvents: (Array.isArray(parsed.nutritionEvents) ? parsed.nutritionEvents : []).map((e: unknown, i: number) => {
                    const event = e as Record<string, unknown>;
                    return {
                    id: `nutrition-${i}`,
                    time: e.time,
                    relativeTime: cleanString(e.relativeTime || ''),
                    title: cleanString(e.title || ''),
                    description: cleanString(e.description || ''),
                    type: event.type,
                    };
                }),
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockSmartAlertsInSW(workouts, muscleStatuses, readinessScore);
}

async function generateWorkoutRecommendationsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number,
    symmetryScore: number,
    focusDistribution: { legs: number; push: number; pull: number },
    apiKey?: string
): Promise<WorkoutRecommendations> {
    if (!apiKey) {
        return generateMockWorkoutRecommendationsInSW(workouts, muscleStatuses, readinessScore, symmetryScore, focusDistribution);
    }

    try {
        const muscleSummary = formatMuscleStatusForSW(muscleStatuses);

        const prompt = `Generate workout recommendations in JSON format:
{
  "readinessStatus": "Go Heavy|Moderate|Rest",
  "recommendedWorkout": {
    "name": "workout name",
    "description": "why this workout",
    "duration": number in minutes,
    "intensity": "low|medium|high",
    "muscleGroups": ["muscle1", "muscle2"],
    "exercises": [{"name": "exercise", "sets": number, "reps": "8-12", "rest": "60s"}]
  },
  "muscleBalance": {
    "imbalances": [{"muscle": "name", "side": "left|right|both", "severity": "mild|moderate|severe", "recommendation": "suggestion"}]
  },
  "correctiveExercises": [{"name": "exercise", "muscle": "target muscle", "reason": "why", "sets": number, "reps": string}],
  "recoveryPredictions": [{"muscle": "name", "hoursUntilReady": number, "recommendedActivity": "rest|light|moderate|heavy"}]
}

Readiness: ${readinessScore}%
Symmetry: ${symmetryScore}%
Focus: Legs ${focusDistribution.legs}%, Push ${focusDistribution.push}%, Pull ${focusDistribution.pull}%
Muscle status: ${muscleSummary}

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
        
        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };
            
            return {
                readinessStatus: parsed.readinessStatus || 'Moderate',
                recommendedWorkout: parsed.recommendedWorkout ? {
                    name: cleanString(parsed.recommendedWorkout.name || ''),
                    description: cleanString(parsed.recommendedWorkout.description || ''),
                    duration: parsed.recommendedWorkout.duration,
                    intensity: parsed.recommendedWorkout.intensity,
                    muscleGroups: (parsed.recommendedWorkout.muscleGroups || []).map((m: any) => cleanString(String(m))),
                    exercises: (parsed.recommendedWorkout.exercises || []).map((e: any) => ({
                        name: cleanString(e.name || ''),
                        sets: e.sets,
                        reps: cleanString(e.reps || ''),
                        rest: cleanString(e.rest || ''),
                    })),
                } : null,
                muscleBalance: {
                    imbalances: (parsed.muscleBalance?.imbalances || []).map((im: any, i: number) => ({
                        id: `imbalance-${i}`,
                        muscle: cleanString(im.muscle || ''),
                        side: im.side,
                        severity: im.severity,
                        recommendation: cleanString(im.recommendation || ''),
                    })),
                },
                correctiveExercises: (parsed.correctiveExercises || []).map((ex: any, i: number) => ({
                    id: `corrective-${i}`,
                    name: cleanString(ex.name || ''),
                    muscle: cleanString(ex.muscle || ''),
                    reason: cleanString(ex.reason || ''),
                    sets: ex.sets,
                    reps: cleanString(ex.reps || ''),
                })),
                recoveryPredictions: (parsed.recoveryPredictions || []).map((pred: any, i: number) => ({
                    id: `recovery-${i}`,
                    muscle: cleanString(pred.muscle || ''),
                    hoursUntilReady: pred.hoursUntilReady,
                    recommendedActivity: pred.recommendedActivity,
                })),
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockWorkoutRecommendationsInSW(workouts, muscleStatuses, readinessScore, symmetryScore, focusDistribution);
}

// Helper functions for formatting data in SW
function formatWorkoutSummaryForSW(workouts: Workout[], personalRecords?: PersonalRecord[]): string {
    if (workouts.length === 0) return 'No workouts logged yet.';
    
    const recent = workouts.slice(0, 10);
    return recent.map((w) => {
        const date = new Date(w.date).toLocaleDateString();
        const exercises = w.exercises?.slice(0, 5).map((e) => `${e.exerciseName} (${e.sets.length} sets)`).join(', ') || 'No exercises';
        return `${date}: ${exercises} - ${w.totalVolume}kg total`;
    }).join('\n');
}

function formatMuscleStatusForSW(muscleStatuses: MuscleStatus[]): string {
    if (muscleStatuses.length === 0) return 'No muscle status data available.';
    
    return muscleStatuses.map((m) => {
        const name = m.muscle.replace(/_/g, ' ');
        return `${name}: ${m.recoveryPercentage}% (${m.recoveryStatus})`;
    }).join(', ');
}

// Mock generation functions for when API key is not available
function generateMockProgressAnalysisInSW(
    workouts: Workout[],
    personalRecords: PersonalRecord[],
    volumeTrend: Array<{ date: string; totalVolume: number }>,
    consistencyScore: number,
    previousConsistencyScore: number,
    workoutCount: number,
    previousWorkoutCount: number
): ProgressAnalysis {
    if (workouts.length === 0) {
        return {
            breakthrough: undefined,
            consistencyScore: 0,
            consistencyChange: 0,
            workoutCount: 0,
            workoutCountChange: 0,
            volumeTrend: {
                current: 0,
                previous: 0,
                changePercent: 0,
                weeklyData: [],
            },
            plateaus: [],
            formChecks: [],
            trainingPatterns: [],
        };
    }

    const latestPR = personalRecords.length > 0 
        ? personalRecords.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())[0]
        : undefined;
    
    const breakthrough = latestPR ? {
        exercise: latestPR.exerciseName,
        projectedWeight: latestPR.maxWeight + (latestPR.maxWeight * 0.05),
        improvementPercent: 5,
        reason: 'Based on your recent progress, you may be ready for a slight increase.',
    } : undefined;

    return {
        breakthrough,
        consistencyScore,
        consistencyChange: consistencyScore - previousConsistencyScore,
        workoutCount,
        workoutCountChange: workoutCount - previousWorkoutCount,
        volumeTrend: {
            current: volumeTrend[volumeTrend.length - 1]?.totalVolume || 0,
            previous: volumeTrend[0]?.totalVolume || 0,
            changePercent: volumeTrend.length > 1 && volumeTrend[0].totalVolume > 0
                ? ((volumeTrend[volumeTrend.length - 1].totalVolume - volumeTrend[0].totalVolume) / volumeTrend[0].totalVolume) * 100
                : 0,
            weeklyData: volumeTrend.map((v, i) => ({ week: `WEEK ${i + 1}`, volume: v.totalVolume })),
        },
        plateaus: [],
        formChecks: [],
        trainingPatterns: [],
    };
}

function generateMockSmartAlertsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number
): SmartAlerts {
    return {
        readinessScore,
        readinessStatus: readinessScore >= 80 ? 'optimal' : readinessScore >= 60 ? 'good' : 'moderate',
        readinessMessage: readinessScore >= 80 
            ? 'Your body is ready for intense training.'
            : readinessScore >= 60
            ? 'You can train, but consider moderate intensity.'
            : 'Consider taking a rest day or light activity.',
        criticalAlerts: [],
        suggestions: [],
        nutritionEvents: [],
    };
}

function generateMockWorkoutRecommendationsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number,
    symmetryScore: number,
    focusDistribution: { legs: number; push: number; pull: number }
): WorkoutRecommendations {
    return {
        readinessStatus: readinessScore >= 80 ? 'Go Heavy' : readinessScore >= 60 ? 'Moderate' : 'Rest',
        recommendedWorkout: null,
        muscleBalance: {
            imbalances: [],
        },
        correctiveExercises: [],
        recoveryPredictions: [],
    };
}

// Claim clients immediately
self.skipWaiting();
clientsClaim();

