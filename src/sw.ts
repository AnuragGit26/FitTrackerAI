/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';
import type { AIContext, InsightType, AIInsightsResults, AIInsightsErrors, SyncEvent, PeriodicSyncEvent } from '@/types/serviceWorker';
import type { Workout } from '@/types/workout';
import type { MuscleStatus } from '@/types/muscle';
import { MuscleGroup, DEFAULT_RECOVERY_SETTINGS } from '@/types/muscle';
import type { PersonalRecord, StrengthProgression } from '@/types/analytics';
import type { RecoveryPrediction, WorkoutRecommendations, ProgressAnalysis, SmartAlerts } from '@/types/insights';

declare const self: ServiceWorkerGlobalScope;

// Precache all of the assets generated by the build process
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    ({ request, url }: { request: Request; url: URL }) => {
        if (request.mode !== 'navigate') {
            return false;
        }
        if (url.pathname.startsWith('/_')) {
            return false;
        }
        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        }
        return true;
    },
    createHandlerBoundToURL('/index.html')
);

// Cache AI-related API calls with IndexedDB persistence
// This allows AI responses to be cached across sessions
registerRoute(
    ({ url }) => url.pathname.includes('/api/ai') || url.searchParams.has('ai-cache'),
    new NetworkFirst({
        cacheName: 'ai-responses',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 24 * 60 * 60, // 24 hours
                purgeOnQuotaError: true,
            }),
        ],
    })
);

// Cache static assets
registerRoute(
    ({ request }) => request.destination === 'image' || request.destination === 'font',
    new CacheFirst({
        cacheName: 'static-assets',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
            }),
        ],
    })
);

// Background sync for AI requests (when offline)
self.addEventListener('sync', (event: Event) => {
    const syncEvent = event as SyncEvent;
    if (syncEvent.tag === 'ai-request-sync') {
        syncEvent.waitUntil(handleAISync());
    }

    if (syncEvent.tag === 'workout-reminder-sync') {
        syncEvent.waitUntil(checkScheduledWorkoutReminders());
    }
});

async function handleAISync(): Promise<void> {
    // This would handle queued AI requests when back online
    // Implementation depends on your specific needs
}

// Periodic background sync for AI refresh checks (every hour)
self.addEventListener('periodicsync', (event: Event) => {
    const periodicSyncEvent = event as PeriodicSyncEvent;
    if (periodicSyncEvent.tag === 'ai-refresh-check') {
        periodicSyncEvent.waitUntil(checkAIRefresh());
    }

    if (periodicSyncEvent.tag === 'recovery-check') {
        periodicSyncEvent.waitUntil(checkMuscleRecovery());
    }
});

async function checkAIRefresh(): Promise<void> {
    // Check if 24 hours have passed and trigger refresh if needed
    // This runs in the background even when app is closed

    // Send message to clients to check refresh status
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'AI_REFRESH_CHECK',
            timestamp: Date.now(),
        });
    });
}

async function checkScheduledWorkoutReminders(): Promise<void> {
    // Send message to clients to check and trigger reminders
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'CHECK_WORKOUT_REMINDERS',
            timestamp: Date.now(),
        });
    });
}

async function checkMuscleRecovery(): Promise<void> {
    // Send message to clients to check muscle recovery
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
        client.postMessage({
            type: 'CHECK_MUSCLE_RECOVERY',
            timestamp: Date.now(),
        });
    });
}

// Handle messages from the main app
self.addEventListener('message', (event: ExtendableMessageEvent) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }

    if (event.data && event.data.type === 'CACHE_AI_RESPONSE') {
        // Cache AI response in IndexedDB via Cache API
        const { fingerprint, insightType, data } = event.data;
        cacheAIResponse(fingerprint, insightType, data);
    }

    if (event.data && event.data.type === 'GET_CACHED_AI') {
        // Retrieve cached AI response
        const { fingerprint, insightType } = event.data;
        getCachedAIResponse(fingerprint, insightType).then((cached) => {
            event.ports[0].postMessage({ cached });
        });
    }

    if (event.data && event.data.type === 'FETCH_AI_INSIGHTS') {
        // Trigger background AI insights fetch
        const { context, fingerprint, insightTypes, userId, apiKey } = event.data;
        fetchAIInsightsInBackground(context, fingerprint, insightTypes, userId, apiKey)
            .catch((error) => {
                console.error('[SW] Background AI fetch failed:', error);
                sendMessageToClients('AI_INSIGHTS_ERROR', {
                    error: error.message,
                    fingerprint,
                    insightTypes,
                });
            });
    }

    // Notification scheduling handlers
    if (event.data && event.data.type === 'SCHEDULE_WORKOUT_REMINDER') {
        const { notification } = event.data;
        scheduleWorkoutReminderNotification(notification);
    }

    if (event.data && event.data.type === 'CANCEL_WORKOUT_REMINDER') {
        const { notificationId } = event.data;
        cancelScheduledNotification(notificationId);
    }

    if (event.data && event.data.type === 'SHOW_MUSCLE_RECOVERY_NOTIFICATION') {
        const { notification } = event.data;
        showMuscleRecoveryNotification(notification);
    }

    if (event.data && event.data.type === 'CLEAR_ALL_NOTIFICATIONS') {
        clearAllScheduledNotifications();
    }

    if (event.data && event.data.type === 'CLEAR_ALL_CACHES') {
        // Clear all caches from service worker context
        clearAllServiceWorkerCaches().then(() => {
            // Send confirmation back to client
            if (event.ports && event.ports[0]) {
                event.ports[0].postMessage({ type: 'CACHE_CLEARED' });
            }
        });
    }
});

// Notification storage in service worker
const scheduledNotifications = new Map<string, { timeoutId: number; notification: any }>();

async function scheduleWorkoutReminderNotification(notification: any): Promise<void> {
    const now = Date.now();
    const delay = notification.scheduledTime - now;

    if (delay <= 0) {
        // Schedule immediately if time has passed
        showWorkoutReminderNotification(notification);
        return;
    }

    const timeoutId = self.setTimeout(() => {
        showWorkoutReminderNotification(notification);
        scheduledNotifications.delete(notification.id);
    }, delay) as unknown as number;

    scheduledNotifications.set(notification.id, { timeoutId, notification });
}

function cancelScheduledNotification(notificationId: string): void {
    const scheduled = scheduledNotifications.get(notificationId);
    if (scheduled) {
        self.clearTimeout(scheduled.timeoutId);
        scheduledNotifications.delete(notificationId);
    }
}

function clearAllScheduledNotifications(): void {
    scheduledNotifications.forEach(({ timeoutId }) => {
        self.clearTimeout(timeoutId);
    });
    scheduledNotifications.clear();
}

async function showWorkoutReminderNotification(notification: any): Promise<void> {
    const title = `Workout Reminder: ${notification.data.workoutName || 'Workout'}`;
    const body = `Your ${notification.data.workoutName || 'workout'} is scheduled soon!`;
    const icon = '/assests/img/fittrackAI_icon.png';
    const badge = '/assests/img/fittrackAI_icon.png';

    const options: NotificationOptions = {
        body,
        icon,
        badge,
        tag: `workout-reminder-${notification.data.workoutId || notification.id}`,
        requireInteraction: false,
        data: {
            type: 'workout_reminder',
            workoutId: notification.data.workoutId,
            url: '/planner',
        },
    };

    try {
        await self.registration.showNotification(title, options);
    } catch (error) {
        console.error('[SW] Failed to show workout reminder notification:', error);
    }
}

async function showMuscleRecoveryNotification(notification: any): Promise<void> {
    const muscleName = notification.data.muscle
        ? notification.data.muscle.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())
        : 'Muscle';

    const title = `${muscleName} is Ready!`;
    const body = `Your ${muscleName.toLowerCase()} has fully recovered and is ready for training`;
    const icon = '/assests/img/fittrackAI_icon.png';
    const badge = '/assests/img/fittrackAI_icon.png';

    // Create tag with muscle name and date to allow one notification per day per muscle
    const today = new Date().toISOString().split('T')[0];
    const tag = `muscle-recovery-${notification.data.muscle || 'unknown'}-${today}`;

    const options: NotificationOptions = {
        body,
        icon,
        badge,
        tag,
        requireInteraction: false,
        data: {
            type: 'muscle_recovery',
            muscle: notification.data.muscle,
            url: '/rest',
        },
    };

    try {
        await self.registration.showNotification(title, options);
    } catch (error) {
        console.error('[SW] Failed to show muscle recovery notification:', error);
    }
}

// Notification click handler
self.addEventListener('notificationclick', (event: NotificationEvent) => {
    event.notification.close();

    const data = event.notification.data;
    const url = data?.url || '/';

    event.waitUntil(
        self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clients) => {
            // Check if there's already a window/tab open with the target URL
            for (const client of clients) {
                if (client.url === url && 'focus' in client) {
                    return client.focus();
                }
            }
            // If not, open a new window/tab
            if (self.clients.openWindow) {
                return self.clients.openWindow(url);
            }
        })
    );
});

async function cacheAIResponse(
    fingerprint: string,
    insightType: string,
    data: unknown
): Promise<void> {
    try {
        const cache = await caches.open('ai-responses');
        const response = new Response(JSON.stringify(data), {
            headers: { 'Content-Type': 'application/json' },
        });
        await cache.put(`/ai-cache/${insightType}/${fingerprint}`, response);
    } catch (error) {
        console.error('[SW] Failed to cache AI response:', error);
    }
}

async function getCachedAIResponse(
    fingerprint: string,
    insightType: string
): Promise<unknown | null> {
    try {
        const cache = await caches.open('ai-responses');
        const cached = await cache.match(`/ai-cache/${insightType}/${fingerprint}`);

        if (cached) {
            return await cached.json();
        }

        return null;
    } catch (error) {
        console.error('[SW] Failed to get cached AI response:', error);
        return null;
    }
}

async function clearAllServiceWorkerCaches(): Promise<void> {
    try {
        // Get all cache names
        const cacheNames = await caches.keys();
        
        // Delete all caches
        const deletePromises = cacheNames.map(cacheName => {
            return caches.delete(cacheName);
        });
        
        await Promise.all(deletePromises);
    } catch (error) {
        // eslint-disable-next-line no-console
        console.error('[SW] Failed to clear caches:', error);
        throw error;
    }
}

// Send message to all connected clients
async function sendMessageToClients(type: string, data: Record<string, unknown>): Promise<void> {
    try {
        const clients = await self.clients.matchAll({ includeUncontrolled: true });
        clients.forEach((client) => {
            client.postMessage({
                type,
                ...data,
                timestamp: Date.now(),
            });
        });
    } catch (error) {
        console.error('[SW] Failed to send message to clients:', error);
    }
}

// Fetch AI insights in background
async function fetchAIInsightsInBackground(
    context: AIContext,
    fingerprint: string,
    insightTypes: InsightType[],
    _userId?: string,
    apiKey?: string
): Promise<void> {

    const results: AIInsightsResults = {};
    const errors: AIInsightsErrors = {};

    // Fetch each insight type in parallel
    const fetchPromises = insightTypes.map(async (insightType) => {
        try {
            let result: ProgressAnalysis | SmartAlerts | WorkoutRecommendations | null = null;

            if (insightType === 'progress') {
                result = await generateProgressAnalysisInSW(
                    context.currentMonthWorkouts,
                    context.personalRecords,
                    context.strengthProgression,
                    context.volumeTrend,
                    context.metrics?.consistencyScore ?? 0,
                    context.previousMetrics?.consistencyScore ?? 0,
                    context.metrics?.workoutCount ?? 0,
                    context.previousMetrics?.workoutCount ?? 0,
                    context.comparisonPeriodLabel || 'last month',
                    apiKey
                );
            } else if (insightType === 'insights') {
                result = await generateSmartAlertsInSW(
                    context.currentMonthWorkouts,
                    context.muscleStatuses,
                    context.readinessScore,
                    apiKey
                );
            } else if (insightType === 'recommendations') {
                result = await generateWorkoutRecommendationsInSW(
                    context.currentMonthWorkouts,
                    context.muscleStatuses,
                    context.readinessScore,
                    context.metrics?.symmetryScore ?? 85,
                    context.metrics?.focusDistribution ?? { legs: 33, push: 33, pull: 34 },
                    apiKey,
                    context.userLevel || 'intermediate',
                    context.baseRestInterval || 48
                );
            }

            if (result) {
                // Type assertion needed for union type assignment
                (results as Record<string, ProgressAnalysis | SmartAlerts | WorkoutRecommendations>)[insightType] = result as ProgressAnalysis | SmartAlerts | WorkoutRecommendations;
                // Cache the result
                await cacheAIResponse(fingerprint, insightType, result);
            }
        } catch (error: any) {
            console.error(`[SW] Failed to generate ${insightType}:`, error);
            errors[insightType] = error.message || 'Unknown error';
        }
    });

    await Promise.allSettled(fetchPromises);

    // Send results back to main thread
    sendMessageToClients('AI_INSIGHTS_READY', {
        fingerprint,
        results,
        errors: Object.keys(errors).length > 0 ? errors : undefined,
    });
}

// Helper functions to generate AI insights in service worker
// These make direct API calls to Gemini since SW can't import modules
async function generateProgressAnalysisInSW(
    workouts: Workout[],
    personalRecords: PersonalRecord[],
    _strengthProgression: StrengthProgression[],
    volumeTrend: Array<{ date: string; totalVolume: number }>,
    consistencyScore: number,
    previousConsistencyScore: number,
    workoutCount: number,
    previousWorkoutCount: number,
    comparisonPeriodLabel: string = 'last month',
    apiKey?: string
): Promise<ProgressAnalysis> {
    if (!apiKey) {
        return generateMockProgressAnalysisInSW(
            workouts,
            personalRecords,
            volumeTrend,
            consistencyScore,
            previousConsistencyScore,
            workoutCount,
            previousWorkoutCount
        );
    }

    try {
        const workoutSummary = formatWorkoutSummaryForSW(workouts, personalRecords);
        const prSummary = personalRecords.length > 0
            ? personalRecords.slice(0, 10).map((pr) => `${pr.exerciseName}: ${pr.maxWeight}kg x ${pr.maxReps} reps (${new Date(pr.date).toLocaleDateString()})`).join('\n')
            : 'No PRs yet';
        const volumeTrendSummary = volumeTrend.length > 20
            ? `${volumeTrend.slice(0, 10).map((v) => `${v.date}: ${v.totalVolume}kg`).join(', ')}... (${volumeTrend.length} total weeks)`
            : volumeTrend.map((v) => `${v.date}: ${v.totalVolume}kg`).join(', ');

        const volumeChange = volumeTrend.length > 1 && volumeTrend[0].totalVolume > 0
            ? Math.round(((volumeTrend[volumeTrend.length - 1].totalVolume - volumeTrend[0].totalVolume) / volumeTrend[0].totalVolume) * 100)
            : 0;
        const consistencyChange = consistencyScore - previousConsistencyScore;
        const workoutCountChange = workoutCount - previousWorkoutCount;
        const prCount = personalRecords.length;
        const recentPRs = personalRecords.filter((pr: PersonalRecord) => {
            const prDate = new Date(pr.date);
            const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            return prDate >= sevenDaysAgo;
        }).length;

        const prompt = `Analyze workout progress and provide detailed insights in JSON format:
{
  "breakthrough": {
    "exercise": "exercise name or null",
    "projectedWeight": number or null,
    "improvementPercent": number or null,
    "reason": "brief explanation with specific data points"
  },
  "plateaus": [{"exercise": "name", "weight": number, "weeksStuck": number, "suggestion": "specific tip with data context"}],
  "formChecks": [{"exercise": "name", "issue": "description", "muscleGroup": "muscle"}],
  "trainingPatterns": [{"type": "sleep|caffeine|timing", "title": "title", "description": "description", "impact": "impact statement with metrics"}]
}

Performance Metrics:
- Consistency Score: ${consistencyScore}% (${consistencyChange >= 0 ? '+' : ''}${consistencyChange}% change from previous period)
- Workout Count: ${workoutCount} workouts this month (${workoutCountChange >= 0 ? '+' : ''}${workoutCountChange} vs ${comparisonPeriodLabel})
- Volume Trend: ${volumeChange >= 0 ? '+' : ''}${volumeChange}% change vs ${comparisonPeriodLabel} (Current: ${Math.round(volumeTrend[volumeTrend.length - 1]?.totalVolume || 0)}kg, Previous: ${Math.round(volumeTrend[0]?.totalVolume || 0)}kg)
- Personal Records: ${prCount} total PRs, ${recentPRs} in last 7 days

Workout Data:
${workoutSummary}

Personal Records:
${prSummary}

Volume Trend (${volumeTrend.length} data points):
${volumeTrendSummary}

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Include specific metrics, percentages, and data points in explanations
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);

        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };

            const cleanObject = (obj: unknown): unknown => {
                if (typeof obj === 'string') return cleanString(obj);
                if (Array.isArray(obj)) return obj.map(cleanObject);
                if (obj && typeof obj === 'object') {
                    const cleaned: Record<string, unknown> = {};
                    for (const [key, value] of Object.entries(obj)) {
                        cleaned[key] = cleanObject(value);
                    }
                    return cleaned;
                }
                return obj;
            };

            const cleaned = cleanObject(parsed) as Record<string, unknown>;
            const breakthrough = cleaned.breakthrough as { exercise?: string; projectedWeight?: number; improvementPercent?: number; reason?: string } | undefined;

            return {
                breakthrough: breakthrough?.exercise && 
                    breakthrough.projectedWeight !== undefined && 
                    breakthrough.improvementPercent !== undefined ? {
                    exercise: cleanString(breakthrough.exercise),
                    projectedWeight: breakthrough.projectedWeight,
                    improvementPercent: breakthrough.improvementPercent,
                    reason: cleanString(breakthrough.reason || ''),
                } : undefined,
                consistencyScore,
                consistencyChange: consistencyScore - previousConsistencyScore,
                workoutCount,
                workoutCountChange: workoutCount - previousWorkoutCount,
                volumeTrend: {
                    current: volumeTrend[volumeTrend.length - 1]?.totalVolume || 0,
                    previous: volumeTrend[0]?.totalVolume || 0,
                    changePercent: volumeTrend.length > 1 && volumeTrend[0].totalVolume > 0
                        ? ((volumeTrend[volumeTrend.length - 1].totalVolume - volumeTrend[0].totalVolume) / volumeTrend[0].totalVolume) * 100
                        : 0,
                    weeklyData: volumeTrend.map((v, i) => ({ week: `WEEK ${i + 1}`, volume: v.totalVolume })),
                },
                plateaus: (Array.isArray(cleaned.plateaus) ? cleaned.plateaus : []).map((p: unknown) => {
                    const plateau = p as Record<string, unknown>;
                    return {
                        exercise: cleanString(String(plateau.exercise || '')),
                        weight: (plateau.weight as number) || 0,
                        weeksStuck: (plateau.weeksStuck as number) || 0,
                        suggestion: cleanString(String(plateau.suggestion || '')),
                    };
                }),
                formChecks: (Array.isArray(cleaned.formChecks) ? cleaned.formChecks : []).map((f: unknown) => {
                    const formCheck = f as Record<string, unknown>;
                    return {
                        exercise: cleanString(String(formCheck.exercise || '')),
                        issue: cleanString(String(formCheck.issue || '')),
                        muscleGroup: (formCheck.muscleGroup as MuscleGroup) || 'chest',
                    };
                }),
                trainingPatterns: (Array.isArray(cleaned.trainingPatterns) ? cleaned.trainingPatterns : []).map((t: unknown, i: number) => {
                    const pattern = t as Record<string, unknown>;
                    return {
                        id: `pattern-${i}`,
                        type: (pattern.type as 'sleep' | 'caffeine' | 'timing' | 'other') || 'other',
                        title: cleanString(String(pattern.title || '')),
                        description: cleanString(String(pattern.description || '')),
                        impact: cleanString(String(pattern.impact || '')),
                    };
                }),
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockProgressAnalysisInSW(
        workouts,
        personalRecords,
        volumeTrend,
        consistencyScore,
        previousConsistencyScore,
        workoutCount,
        previousWorkoutCount
    );
}

async function generateSmartAlertsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number,
    apiKey?: string
): Promise<SmartAlerts> {
    if (!apiKey) {
        return generateMockSmartAlertsInSW(workouts, muscleStatuses, readinessScore);
    }

    try {
        const muscleSummary = formatMuscleStatusForSW(muscleStatuses);
        const workoutSummary = formatWorkoutSummaryForSW(workouts);

        // Calculate recovery details
        const overworkedMuscles = muscleStatuses.filter((m: MuscleStatus) => m.recoveryStatus === 'overworked');
        const readyMuscles = muscleStatuses.filter((m: MuscleStatus) => m.recoveryStatus === 'ready');
        const avgRecovery = muscleStatuses.length > 0
            ? Math.round(muscleStatuses.reduce((sum: number, m: MuscleStatus) => sum + m.recoveryPercentage, 0) / muscleStatuses.length)
            : 85;
        const avgWorkload = muscleStatuses.length > 0
            ? Math.round(muscleStatuses.reduce((sum: number, m: MuscleStatus) => sum + m.workloadScore, 0) / muscleStatuses.length)
            : 0;

        // Get recent workout intensity
        const recentWorkouts = workouts.slice(0, 5);
        const avgRecentVolume = recentWorkouts.length > 0
            ? Math.round(recentWorkouts.reduce((sum: number, w: Workout) => sum + w.totalVolume, 0) / recentWorkouts.length)
            : 0;

        const prompt = `Generate smart alerts with detailed context in JSON format:
{
  "readinessStatus": "optimal|good|moderate|low",
  "readinessMessage": "actionable message with specific readiness score and recovery data",
  "criticalAlerts": [{"type": "critical|warning", "title": "title", "message": "message with specific metrics (recovery %, workload, hours since workout)", "muscleGroup": "muscle"}],
  "suggestions": [{"type": "deload|sleep|nutrition", "title": "title", "description": "description with data context"}],
  "nutritionEvents": [{"time": "HH:MM", "relativeTime": "In X mins", "title": "title", "description": "description", "type": "protein|carb|meal"}]
}

Recovery Metrics:
- Readiness Score: ${readinessScore}%
- Average Recovery: ${avgRecovery}%
- Average Workload: ${avgWorkload}
- Overworked Muscles: ${overworkedMuscles.length}
- Ready Muscles: ${readyMuscles.length}

Muscle Status Details:
${muscleSummary}

Recent Training:
${workoutSummary}
- Average Recent Volume: ${avgRecentVolume}kg per workout
- Recent Workouts: ${recentWorkouts.length} in last period

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- Include specific metrics (percentages, hours, volumes) in messages and descriptions
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);

        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };

            return {
                readinessScore,
                readinessStatus: parsed.readinessStatus || 'good',
                readinessMessage: cleanString(parsed.readinessMessage || 'System is operating normally.'),
                criticalAlerts: (Array.isArray(parsed.criticalAlerts) ? parsed.criticalAlerts : []).map((a: unknown, i: number) => {
                    const alert = a as Record<string, unknown>;
                    return {
                        id: `alert-${i}`,
                        type: (alert.type as 'critical' | 'warning' | 'info') || 'info',
                        title: cleanString(String(alert.title || '')),
                        message: cleanString(String(alert.message || '')),
                        muscleGroup: (alert.muscleGroup as MuscleGroup) || 'chest',
                    };
                }),
                suggestions: (Array.isArray(parsed.suggestions) ? parsed.suggestions : []).map((s: unknown, i: number) => {
                    const suggestion = s as Record<string, unknown>;
                    return {
                        id: `suggestion-${i}`,
                        type: (suggestion.type as 'deload' | 'sleep' | 'nutrition' | 'workout') || 'workout',
                        title: cleanString(String(suggestion.title || '')),
                        description: cleanString(String(suggestion.description || '')),
                    };
                }),
                nutritionEvents: (Array.isArray(parsed.nutritionEvents) ? parsed.nutritionEvents : []).map((e: unknown, i: number) => {
                    const event = e as Record<string, unknown>;
                    return {
                        id: `nutrition-${i}`,
                        time: String(event.time || ''),
                        relativeTime: cleanString(String(event.relativeTime || '')),
                        title: cleanString(String(event.title || '')),
                        description: cleanString(String(event.description || '')),
                        type: (event.type as 'protein' | 'carb' | 'meal' | 'supplement') || 'meal',
                    };
                }),
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockSmartAlertsInSW(workouts, muscleStatuses, readinessScore);
}

// Helper function to categorize muscle groups
function categorizeMuscleGroupSW(muscle: MuscleGroup): 'legs' | 'push' | 'pull' {
    const legs = [
        MuscleGroup.QUADS,
        MuscleGroup.HAMSTRINGS,
        MuscleGroup.GLUTES,
        MuscleGroup.CALVES,
        MuscleGroup.HIP_FLEXORS,
    ];
    const push = [
        MuscleGroup.CHEST,
        MuscleGroup.UPPER_CHEST,
        MuscleGroup.LOWER_CHEST,
        MuscleGroup.FRONT_DELTS,
        MuscleGroup.SIDE_DELTS,
        MuscleGroup.TRICEPS,
    ];
    const pull = [
        MuscleGroup.BACK,
        MuscleGroup.LATS,
        MuscleGroup.TRAPS,
        MuscleGroup.RHOMBOIDS,
        MuscleGroup.BICEPS,
        MuscleGroup.REAR_DELTS,
    ];
    if (legs.includes(muscle)) return 'legs';
    if (push.includes(muscle)) return 'push';
    if (pull.includes(muscle)) return 'pull';
    return 'legs';
}

// Calculate recovery predictions for the next 7 days (duplicated from aiService.ts for SW context)
function calculateRecoveryPredictionsSW(
    muscleStatuses: MuscleStatus[],
    userLevel: 'beginner' | 'intermediate' | 'advanced',
    baseRestInterval: number
): RecoveryPrediction[] {
    const predictions: RecoveryPrediction[] = [];
    const today = new Date();

    // Helper to add days
    const addDays = (date: Date, days: number): Date => {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    };

    // Helper to format date as day label
    const formatDayLabel = (date: Date): string => {
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        return days[date.getDay()];
    };

    // Helper to calculate hours difference
    const differenceInHours = (dateLeft: Date, dateRight: Date): number => {
        const diffTime = dateLeft.getTime() - dateRight.getTime();
        return Math.round(diffTime / (1000 * 60 * 60));
    };

    for (let i = 0; i < 7; i++) {
        const targetDate = addDays(today, i);
        const dayLabel = formatDayLabel(targetDate);

        let totalRecovery = 0;
        let count = 0;
        const readyMusclesByCategory: { legs: MuscleGroup[]; push: MuscleGroup[]; pull: MuscleGroup[] } = {
            legs: [],
            push: [],
            pull: [],
        };

        muscleStatuses.forEach((status) => {
            if (!status.lastWorked) {
                totalRecovery += 100;
                count++;
                const category = categorizeMuscleGroupSW(status.muscle);
                readyMusclesByCategory[category].push(status.muscle);
                return;
            }

            const lastWorked = status.lastWorked instanceof Date
                ? status.lastWorked
                : new Date(status.lastWorked);

            const hoursSinceWorkout = differenceInHours(targetDate, lastWorked);

            if (hoursSinceWorkout < 0) {
                totalRecovery += status.recoveryPercentage;
                count++;
                if (status.recoveryPercentage >= 75) {
                    const category = categorizeMuscleGroupSW(status.muscle);
                    readyMusclesByCategory[category].push(status.muscle);
                }
                return;
            }

            const recoverySettings = DEFAULT_RECOVERY_SETTINGS;
            let baseRecoveryHours = 48;

            if (userLevel === 'beginner') {
                baseRecoveryHours = (recoverySettings.beginnerRestDays[status.muscle] || 2) * 24;
            } else if (userLevel === 'intermediate') {
                baseRecoveryHours = (recoverySettings.intermediateRestDays[status.muscle] || 2) * 24;
            } else {
                baseRecoveryHours = (recoverySettings.advancedRestDays[status.muscle] || 1) * 24;
            }

            if (baseRestInterval !== undefined) {
                const defaultBase = 48;
                const ratio = baseRestInterval / defaultBase;
                baseRecoveryHours = baseRecoveryHours * ratio;
            }

            const workloadMultiplier = 1 + (status.workloadScore / 100);
            const adjustedRecoveryHours = baseRecoveryHours * workloadMultiplier;

            const projectedRecovery = Math.min(
                100,
                Math.max(0, (hoursSinceWorkout / adjustedRecoveryHours) * 100)
            );

            totalRecovery += projectedRecovery;
            count++;

            if (projectedRecovery >= 75) {
                const category = categorizeMuscleGroupSW(status.muscle);
                readyMusclesByCategory[category].push(status.muscle);
            }
        });

        const avgRecovery = count > 0 ? Math.round(totalRecovery / count) : 85;

        let workoutType: 'push' | 'pull' | 'legs' | 'rest' = 'rest';
        if (readyMusclesByCategory.legs.length >= 2) {
            workoutType = 'legs';
        } else if (readyMusclesByCategory.push.length >= 2) {
            workoutType = 'push';
        } else if (readyMusclesByCategory.pull.length >= 2) {
            workoutType = 'pull';
        } else if (avgRecovery >= 75) {
            workoutType = 'rest';
        }

        const prediction = {
            date: targetDate.toISOString().split('T')[0],
            dayLabel,
            workoutType,
            recoveryPercentage: Math.max(1, avgRecovery), // Ensure minimum 1% so bar is always visible
            prPotential: avgRecovery >= 90 ? ['Optimal recovery for PR attempts'] : [],
            fatigueWarnings: avgRecovery < 50 ? ['High fatigue - consider rest'] : [],
        };
        predictions.push(prediction);
    }

    return predictions;
}

async function generateWorkoutRecommendationsInSW(
    workouts: Workout[],
    muscleStatuses: MuscleStatus[],
    readinessScore: number,
    symmetryScore: number,
    focusDistribution: { legs: number; push: number; pull: number },
    apiKey?: string,
    userLevel: 'beginner' | 'intermediate' | 'advanced' = 'intermediate',
    baseRestInterval: number = 48
): Promise<WorkoutRecommendations> {
    // Always calculate recovery predictions (don't rely on AI for this)
    const calculatedPredictions = calculateRecoveryPredictionsSW(muscleStatuses, userLevel, baseRestInterval);

    if (!apiKey) {
        return generateMockWorkoutRecommendationsInSW(workouts, muscleStatuses, readinessScore, symmetryScore, focusDistribution, calculatedPredictions);
    }

    try {
        const muscleSummary = formatMuscleStatusForSW(muscleStatuses);

        // Get ready muscle groups with recovery percentages
        const readyMuscles = muscleStatuses
            .filter((m: MuscleStatus) => m.recoveryPercentage >= 75)
            .sort((a: MuscleStatus, b: MuscleStatus) => b.recoveryPercentage - a.recoveryPercentage)
            .slice(0, 10);
        const readyMusclesList = readyMuscles.length > 0
            ? readyMuscles.map((m: MuscleStatus) => `${m.muscle} (${m.recoveryPercentage}%)`).join(', ')
            : 'None ready';

        // Get recent workout types to avoid repetition
        const recentWorkoutTypes = workouts.slice(0, 5).map((w: Workout) => {
            const exercises = w.exercises?.map((e: any) => e.exerciseName).join(', ') || 'No exercises';
            return `${new Date(w.date).toLocaleDateString()}: ${exercises.substring(0, 50)}...`;
        }).join('\n');

        const prompt = `Generate workout recommendations with comprehensive context in JSON format:
{
  "readinessStatus": "Go Heavy|Moderate|Rest",
  "recommendedWorkout": {
    "name": "workout name",
    "description": "why this workout with specific recovery data",
    "duration": number in minutes,
    "intensity": "low|medium|high",
    "muscleGroups": ["muscle1", "muscle2"],
    "exercises": [{"name": "exercise", "sets": number, "reps": "8-12", "rest": "60s"}]
  },
  "muscleBalance": {
    "imbalances": [{"muscle": "muscle", "leftVolume": number, "rightVolume": number, "imbalancePercent": number}]
  },
  "correctiveExercises": [{"name": "exercise", "description": "why with data context", "targetMuscle": "muscle", "category": "imbalance|posture|weakness"}],
  "recoveryPredictions": [{"muscle": "name", "hoursUntilReady": number, "recommendedActivity": "rest|light|moderate|heavy"}]
}

Recovery & Readiness:
- Readiness Score: ${readinessScore}%
- Ready Muscle Groups: ${readyMusclesList}
- User Level: ${userLevel}
- Base Rest Interval: ${baseRestInterval} hours

Balance Metrics:
- Symmetry Score: ${symmetryScore}%
- Focus Distribution: Legs ${focusDistribution.legs}%, Push ${focusDistribution.push}%, Pull ${focusDistribution.pull}%

Muscle Status Details:
${muscleSummary}

Recent Workouts (to avoid repetition):
${recentWorkoutTypes || 'No recent workouts'}

CRITICAL OUTPUT REQUIREMENTS:
- Output ONLY valid JSON, no markdown formatting, no code blocks, no explanatory text before or after
- Include specific recovery percentages and readiness data in recommendations
- Reference ready muscle groups with their recovery percentages
- All text fields must be clean, professional, and polished - no gibberish, typos, or unpolished content
- Ensure all strings are properly formatted and grammatically correct
- Return only the JSON object, nothing else.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: prompt }]
                }]
            })
        });

        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }

        const data = await response.json();
        let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

        // Clean the response text
        text = text.replace(/^```(?:json|javascript|typescript)?\s*\n?/gm, '').replace(/```\s*$/gm, '').trim();
        const jsonMatch = text.match(/\{[\s\S]*\}/);

        if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            // Clean string fields
            const cleanString = (str: unknown): string => {
                if (typeof str !== 'string') return String(str || '').trim();
                return str.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1').trim();
            };

            return {
                readinessScore,
                readinessStatus: parsed.readinessStatus || 'Moderate',
                recommendedWorkout: parsed.recommendedWorkout ? {
                    id: 'rec-1',
                    name: cleanString(parsed.recommendedWorkout.name || ''),
                    description: cleanString(parsed.recommendedWorkout.description || ''),
                    duration: parsed.recommendedWorkout.duration,
                    intensity: parsed.recommendedWorkout.intensity,
                    muscleGroups: (parsed.recommendedWorkout.muscleGroups || []).map((m: any) => cleanString(String(m))),
                    reason: cleanString(parsed.recommendedWorkout.description || ''),
                } : undefined,
                muscleBalance: {
                    imbalances: (parsed.muscleBalance?.imbalances || []).map((im: any, i: number) => ({
                        id: `imbalance-${i}`,
                        muscle: cleanString(im.muscle || '') as MuscleGroup,
                        leftVolume: typeof im.leftVolume === 'number' ? im.leftVolume : 0,
                        rightVolume: typeof im.rightVolume === 'number' ? im.rightVolume : 0,
                        imbalancePercent: typeof im.imbalancePercent === 'number' ? im.imbalancePercent : 0,
                        status: (typeof im.imbalancePercent === 'number' && im.imbalancePercent > 10 ? 'imbalanced' : 'balanced') as 'balanced' | 'imbalanced',
                    })),
                    overallScore: symmetryScore,
                },
                correctiveExercises: (parsed.correctiveExercises || []).map((ex: any, i: number) => ({
                    id: `corrective-${i}`,
                    name: cleanString(ex.name || ''),
                    description: cleanString(ex.description || ex.reason || ''),
                    targetMuscle: cleanString(ex.targetMuscle || ex.muscle || '') as MuscleGroup,
                    reason: cleanString(ex.reason || ex.description || ''),
                    category: (cleanString(ex.category || '') as 'imbalance' | 'posture' | 'weakness' | 'mobility') || 'weakness',
                })),
                recoveryPredictions: calculatedPredictions,
            };
        }
    } catch (error) {
        console.error('[SW] AI service error:', error);
    }

    return generateMockWorkoutRecommendationsInSW(workouts, muscleStatuses, readinessScore, symmetryScore, focusDistribution, calculatedPredictions);
}

// Helper functions for formatting data in SW
function formatWorkoutSummaryForSW(workouts: Workout[], _personalRecords?: PersonalRecord[]): string {
    if (workouts.length === 0) return 'No workouts logged yet.';

    const recent = workouts.slice(0, 10);
    return recent.map((w) => {
        const date = new Date(w.date).toLocaleDateString();
        const exercises = w.exercises?.slice(0, 5).map((e) => `${e.exerciseName} (${e.sets.length} sets)`).join(', ') || 'No exercises';
        return `${date}: ${exercises} - ${w.totalVolume}kg total`;
    }).join('\n');
}

function formatMuscleStatusForSW(muscleStatuses: MuscleStatus[]): string {
    if (muscleStatuses.length === 0) return 'No muscle status data available.';

    // Group by recovery status
    const byStatus = new Map<string, MuscleStatus[]>();
    muscleStatuses.forEach((ms: MuscleStatus) => {
        const status = ms.recoveryStatus;
        if (!byStatus.has(status)) {
            byStatus.set(status, []);
        }
        byStatus.get(status)!.push(ms);
    });

    const overworked = byStatus.get('overworked') || [];
    const ready = byStatus.get('ready') || [];
    const recovering = byStatus.get('recovering') || [];
    const others = muscleStatuses.filter(
        (ms: MuscleStatus) => !overworked.includes(ms) && !ready.includes(ms) && !recovering.includes(ms)
    );

    const parts: string[] = [];

    if (overworked.length > 0) {
        parts.push(
            `Overworked: ${overworked.map((m: MuscleStatus) => {
                const hoursAgo = m.lastWorked
                    ? `${Math.round((Date.now() - new Date(m.lastWorked).getTime()) / (1000 * 60 * 60))}h ago`
                    : 'never worked';
                return `${m.muscle} (${m.recoveryPercentage}%, workload: ${m.workloadScore}, ${hoursAgo})`;
            }).join(', ')}`
        );
    }

    if (ready.length > 0) {
        parts.push(
            `Ready: ${ready.map((m: MuscleStatus) => {
                const hoursAgo = m.lastWorked
                    ? `${Math.round((Date.now() - new Date(m.lastWorked).getTime()) / (1000 * 60 * 60))}h ago`
                    : 'never worked';
                return `${m.muscle} (${m.recoveryPercentage}%, ${hoursAgo})`;
            }).join(', ')}`
        );
    }

    if (recovering.length > 0) {
        const avgRecovery = Math.round(
            recovering.reduce((sum: number, m: MuscleStatus) => sum + m.recoveryPercentage, 0) / recovering.length
        );
        const avgWorkload = Math.round(
            recovering.reduce((sum: number, m: MuscleStatus) => sum + m.workloadScore, 0) / recovering.length
        );
        parts.push(`Recovering: ${recovering.length} muscles (avg ${avgRecovery}% recovery, ${avgWorkload} workload)`);
    }

    if (others.length > 0) {
        parts.push(`Other: ${others.length} muscles`);
    }

    return parts.join('\n');
}

// Mock generation functions for when API key is not available
function generateMockProgressAnalysisInSW(
    workouts: Workout[],
    personalRecords: PersonalRecord[],
    volumeTrend: Array<{ date: string; totalVolume: number }>,
    consistencyScore: number,
    previousConsistencyScore: number,
    workoutCount: number,
    previousWorkoutCount: number
): ProgressAnalysis {
    if (workouts.length === 0) {
        return {
            breakthrough: undefined,
            consistencyScore: 0,
            consistencyChange: 0,
            workoutCount: 0,
            workoutCountChange: 0,
            volumeTrend: {
                current: 0,
                previous: 0,
                changePercent: 0,
                weeklyData: [],
            },
            plateaus: [],
            formChecks: [],
            trainingPatterns: [],
        };
    }

    const latestPR = personalRecords.length > 0
        ? personalRecords.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())[0]
        : undefined;

    const breakthrough = latestPR ? {
        exercise: latestPR.exerciseName,
        projectedWeight: latestPR.maxWeight + (latestPR.maxWeight * 0.05),
        improvementPercent: 5,
        reason: 'Based on your recent progress, you may be ready for a slight increase.',
    } : undefined;

    return {
        breakthrough,
        consistencyScore,
        consistencyChange: consistencyScore - previousConsistencyScore,
        workoutCount,
        workoutCountChange: workoutCount - previousWorkoutCount,
        volumeTrend: {
            current: volumeTrend[volumeTrend.length - 1]?.totalVolume || 0,
            previous: volumeTrend[0]?.totalVolume || 0,
            changePercent: volumeTrend.length > 1 && volumeTrend[0].totalVolume > 0
                ? ((volumeTrend[volumeTrend.length - 1].totalVolume - volumeTrend[0].totalVolume) / volumeTrend[0].totalVolume) * 100
                : 0,
            weeklyData: volumeTrend.map((v, i) => ({ week: `WEEK ${i + 1}`, volume: v.totalVolume })),
        },
        plateaus: [],
        formChecks: [],
        trainingPatterns: [],
    };
}

function generateMockSmartAlertsInSW(
    _workouts: Workout[],
    _muscleStatuses: MuscleStatus[],
    readinessScore: number
): SmartAlerts {
    return {
        readinessScore,
        readinessStatus: readinessScore >= 80 ? 'optimal' : readinessScore >= 60 ? 'good' : 'moderate',
        readinessMessage: readinessScore >= 80
            ? 'Your body is ready for intense training.'
            : readinessScore >= 60
                ? 'You can train, but consider moderate intensity.'
                : 'Consider taking a rest day or light activity.',
        criticalAlerts: [],
        suggestions: [],
        nutritionEvents: [],
    };
}

function generateMockWorkoutRecommendationsInSW(
    _workouts: Workout[],
    _muscleStatuses: MuscleStatus[],
    readinessScore: number,
    symmetryScore: number,
    _focusDistribution: { legs: number; push: number; pull: number },
    calculatedPredictions: RecoveryPrediction[]
): WorkoutRecommendations {
    return {
        readinessScore,
        readinessStatus: readinessScore >= 80 ? 'Go Heavy' : readinessScore >= 60 ? 'Moderate' : 'Rest',
        recommendedWorkout: undefined,
        muscleBalance: {
            imbalances: [],
            overallScore: symmetryScore,
        },
        correctiveExercises: [],
        recoveryPredictions: calculatedPredictions,
    };
}

// Claim clients immediately
self.skipWaiting();
clientsClaim();

