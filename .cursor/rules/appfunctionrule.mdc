---
alwaysApply: true
selfEvolving: true
---

# FitTrackAI Application Function Rules

## 0. Rule Intelligence & Self-Update Authority (CRITICAL)

- This rule is **self-aware and self-maintaining**.
- The system may **optimize, extend, or refine this rule** when explicitly commanded
  using instructions such as:
  - "update the rule"
  - "optimize the rule"
  - "extend this rule to handle X"
- Rule updates must:
  - Preserve backward intent
  - Never weaken safety, testing, or review constraints
  - Be additive or clarifying, not destructive
- Every rule update must:
  - Be reasoned with architectural context
  - Avoid ambiguity
  - Remain production-safe

> The rule may evolve, but never regress.

---

## 1. End-User Safety First (NON-NEGOTIABLE)

- Assume **end users cannot handle runtime errors**.
- **Zero runtime errors should occur** - prevent errors entirely rather than catching them.
- Zero unhandled runtime errors across:
  - UI components
  - Domain logic
  - Edge functions
  - Prisma/MongoDB
  - Sync layers
- Failures must:
  - Degrade gracefully
  - Provide user-safe recovery
  - Log internally (no technical leakage)
  - Never expose technical error messages to end users
- **Error handling strategy:**
  - Prevent errors through validation and defensive programming
  - Catch and handle errors at component level (not page level)
  - Use optimistic logging to Vercel for monitoring
  - Display graceful UI fallbacks instead of error states

---

## 2. End-to-End Integration (Strict)

- All functionality must be implemented **E2E**:
- Validate:
- User action ‚Üí persistence ‚Üí rehydration
- No UX regression
- Existing flows remain intact
- Mandatory handling:
- Loading
- Empty
- Error
- Offline
- Partial sync states

---

## 3. Architectural Planning Before Coding (Mandatory)

Before coding, document:

- End-user goal (fitness tracking + AI coaching insights)
- Full user journey
- Data ownership & flow
- Edge Function responsibilities (Supabase):
- Auth
- Secure execution
- Event orchestration
- Prisma + MongoDB:
- Canonical data store
- Schema evolution
- Sync guarantees
- IndexedDB:
- Offline authority
- Reconciliation logic
- Performance expectations
- Failure modes & mitigation

> No planning ‚Üí no code.

---

## 4. Data Architecture & Storage Rules

### Supabase

- **Used ONLY for Edge Functions**
- No permanent data storage
- No business-critical state persistence

### Prisma ORM + MongoDB

- **Single source of truth**
- Strong schema contracts
- Migration-safe updates
- Indexed, query-efficient models

### IndexedDB

- Offline-first UX
- Syncs deterministically with MongoDB
- Handles conflict resolution

---

## 5. Runtime Error Prevention (STRICT)

- **Component-Level Error Handling (MANDATORY):**
  - Wrap all component logic in try-catch blocks at the component level
  - Never rely on page-level error boundaries alone
  - Each component must handle its own errors gracefully
  - Use error boundaries only as a last resort fallback

- **Error Handling Pattern:**
  ```tsx
  // Component-level error handling example
  const MyComponent = () => {
    const [error, setError] = useState<string | null>(null);
    
    const handleAction = async () => {
      try {
        // Component logic here
        await someAsyncOperation();
      } catch (err) {
        // Log to Vercel for monitoring
        logger.error('Component action failed', err, { component: 'MyComponent' });
        
        // Set user-friendly error state
        setError('Something went wrong. Please try again.');
        
        // Graceful degradation - continue with fallback behavior
        // Never throw or crash the component
      }
    };
    
    // Render graceful UI fallback instead of error state when possible
    if (error) {
      return <GracefulFallback message={error} />;
    }
    
    return <NormalUI />;
  };
  ```

- Defensive programming everywhere:
  - Null checks
  - Schema validation
  - AI output sanitization
  - Type guards
  - Default values for all optional data

- All async calls require:
  - Timeout
  - Retry with exponential backoff
  - Fallback behavior
  - Component-level try-catch

- **Optimistic Logging:**
  - Log all errors to Vercel using `logger.error()` or `logger.warn()`
  - Include component context, user context, and error details
  - Never log sensitive user data
  - Use structured logging for better debugging

- **Graceful UI Components:**
  - Components must handle all error states internally
  - Display user-friendly messages, not technical errors
  - Provide recovery actions (retry, skip, use defaults)
  - Never show error boundaries or crash screens to users

- AI-generated insights must:
  - Be validated
  - Be explainable
  - Never silently fail
  - Have component-level error handling

---

## 6. UI/UX Implementation Standards

- Follow existing design language strictly
- Accessibility is mandatory
- Every screen defines:
  - Loading
  - Success
  - Failure (graceful fallback, not error state)
  - Empty
- **Error State Handling:**
  - Never show technical error messages
  - Use graceful fallbacks (empty states, default content, retry buttons)
  - Components should degrade gracefully (show partial data, use defaults)
  - Error boundaries are last resort only - components handle their own errors
- No UI change without validating **user impact**

---

## 7. Build & Lint Validation (MANDATORY PREREQUISITE)

**All code changes MUST pass build and lint validation before completion.**

### Build Validation

- Run `npm run build:prod` (or equivalent) to validate:
  - TypeScript compilation (`tsc --noEmit`)
  - Strict linting (`lint:strict` with 0 max warnings)
  - Production build (`vite build`)
- **Zero build errors allowed**
- **Zero TypeScript errors allowed**
- Build must complete successfully

### Lint Validation

- Run `npm run lint:strict` before completing any code change
- **Zero lint errors allowed**
- **Zero lint warnings allowed** (strict mode)
- Auto-fix when possible: `npm run lint:fix`
- Manual fixes required for non-auto-fixable issues

### Validation Workflow

1. **Before committing code:**
   - Run `npm run lint:strict`
   - Fix all lint errors/warnings
   - Run `npm run build:prod`
   - Verify zero build errors

2. **After code changes:**
   - Re-run validation if dependencies change
   - Verify no new errors introduced
   - Ensure existing functionality still builds

3. **Integration with Code Review:**
   - Build/lint validation is a **prerequisite** for code review
   - No code review until build passes
   - No merge until validation passes

> **No exceptions.** Code with build or lint errors is incomplete and must not be merged.

---

## 8. Agentic Code Review & Quality Gate

Every feature is reviewed as:

### Architect

- Scalability
- Separation of concerns
- No coupling leaks

### Senior Engineer

- Performance
- Maintainability
- No over-engineering
- No dead code

### Product Manager

- Clear user value
- Complete user flow
- Edge cases handled

### Review Checklist

- Clean modular code
- Efficient Prisma queries
- Correct IndexedDB sync
- Secure edge boundaries
- **Build validation passed** (Section 7)
- **Lint validation passed** (Section 7)
- Tests updated
- Rule relevance verified

> Merge only after approval.

---

## 9. Testing Requirements (Agentic & E2E)

Testing must include:

- Full E2E user journeys
- Regression tests
- Edge cases & failure states
- Offline + reconnect flows
- AI insight validation

### Agentic Testing

- Automated verification:
- Before change
- After change
- Validate:
- No regressions
- No runtime errors
- Insight consistency

---

## 10. End-User Perspective (Fitness + AI Coaching)

Always validate as the end user:

- Goal: Track workouts reliably
- Expectation: AI gives actionable, trustworthy insights
- No technical leakage
- Data accuracy is non-negotiable

---

## 11. Component-Level Error Handling (CRITICAL)

### Error Handling Architecture

**Component-Level (Primary):**
- Every component must wrap its logic in try-catch blocks
- Handle errors within the component's scope
- Log errors to Vercel using `logger.error()` or `logger.warn()`
- Display graceful UI fallbacks instead of error states

**Page-Level (Secondary):**
- Error boundaries should only catch unexpected errors
- Not a replacement for component-level handling
- Use as a last resort safety net

### Error Handling Checklist

For every component:

- [ ] All async operations wrapped in try-catch
- [ ] All event handlers have error handling
- [ ] All useEffect hooks handle errors gracefully
- [ ] Errors logged to Vercel with context
- [ ] User-friendly error messages (no technical details)
- [ ] Graceful fallback UI provided
- [ ] Recovery actions available (retry, skip, use defaults)
- [ ] No unhandled promise rejections
- [ ] No thrown errors that escape component

### Error Logging Pattern

```tsx
import { logger } from '@/utils/logger';

// In component
try {
  await operation();
} catch (err) {
  // Log with context
  logger.error('Operation failed in ComponentName', err, {
    component: 'ComponentName',
    action: 'operationName',
    userId: userContextManager.getUserId(),
    context: { /* relevant context */ }
  });
  
  // Set user-friendly state
  setError('Unable to complete action. Please try again.');
  
  // Continue with fallback behavior
  // Never throw or crash
}
```

### Graceful Degradation Patterns

1. **Data Loading Failures:**
   - Show cached/previous data if available
   - Display empty state with retry option
   - Use default values

2. **Action Failures:**
   - Show user-friendly error message
   - Provide retry button
   - Allow user to skip or cancel

3. **Validation Failures:**
   - Show inline validation errors
   - Prevent submission
   - Provide clear guidance

4. **Network Failures:**
   - Queue operations for retry
   - Show offline indicator
   - Allow offline mode continuation

### Avoid These Patterns

- ‚ùå Throwing errors from components
- ‚ùå Relying solely on error boundaries
- ‚ùå Showing technical error messages to users
- ‚ùå Silent failures without logging
- ‚ùå Page-level error handling only
- ‚ùå Unhandled promise rejections

---

## 12. Documentation as a System Contract

- Update:
- README
- Architecture docs
- Prisma schema docs
- `TECHNICAL_DOCUMENTATION.md`
- Comments:
- Minimal
- Explain intent, not syntax
- Architectural decisions must be recorded

---

## 13. Technical Documentation Reference (CRITICAL)

üìÑ `TECHNICAL_DOCUMENTATION.md` (root)

Consult before:

- New features
- Schema changes
- Edge function updates
- AI logic changes
- Performance optimizations

Update when any of the above changes.

---

## 14. AI-Output Schema Contracts (CRITICAL)

AI-generated outputs are treated as **untrusted external inputs**.

No AI response may be:

- Rendered
- Stored
- Acted upon
- Used for recommendations

unless it **strictly conforms** to an approved schema contract.

---

### 14.1 Canonical AI Response Envelope (MANDATORY)

Every AI response must conform to the following envelope:

```ts
type AIResponseEnvelope<T> = {
  schemaVersion: string        // SemVer, e.g. "1.0.0"
  requestId: string            // Traceability across systems
  generatedAt: string          // ISO-8601 UTC timestamp
  confidenceScore: number      // 0.0 ‚Äì 1.0
  explanation: string          // Human-readable reasoning
  data: T                      // Feature-specific payload
}
